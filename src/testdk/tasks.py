"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from testdk import errors, models, utils
from testdk._hooks import HookContext
from testdk.types import BaseModel, OptionalNullable, UNSET
from testdk.utils import get_security_from_env
from typing import Any, Mapping, Optional, Union, cast


class Tasks(BaseSDK):
    r"""Generation task endpoints. These endpoints allow you to submit generation tasks."""

    def flux_pro_1_1_v1_flux_pro_1_1_post(
        self,
        *,
        request: Union[
            models.FluxPro11Inputs, models.FluxPro11InputsTypedDict
        ] = models.FluxPro11Inputs(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseFluxPro11V1FluxPro11Post:
        r"""Generate an image with FLUX 1.1 [pro].

        Submits an image generation task with FLUX 1.1 [pro].

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.FluxPro11Inputs)
        request = cast(models.FluxPro11Inputs, request)

        req = self._build_request(
            method="POST",
            path="/v1/flux-pro-1.1",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, True, "json", Optional[models.FluxPro11Inputs]
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="flux_pro_1_1_v1_flux_pro_1_1_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.ResponseFluxPro11V1FluxPro11Post
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def flux_pro_1_1_v1_flux_pro_1_1_post_async(
        self,
        *,
        request: Union[
            models.FluxPro11Inputs, models.FluxPro11InputsTypedDict
        ] = models.FluxPro11Inputs(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseFluxPro11V1FluxPro11Post:
        r"""Generate an image with FLUX 1.1 [pro].

        Submits an image generation task with FLUX 1.1 [pro].

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.FluxPro11Inputs)
        request = cast(models.FluxPro11Inputs, request)

        req = self._build_request_async(
            method="POST",
            path="/v1/flux-pro-1.1",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, True, "json", Optional[models.FluxPro11Inputs]
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="flux_pro_1_1_v1_flux_pro_1_1_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.ResponseFluxPro11V1FluxPro11Post
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def flux_pro_v1_flux_pro_post(
        self,
        *,
        request: Union[
            models.FluxProInputs, models.FluxProInputsTypedDict
        ] = models.FluxProInputs(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseFluxProV1FluxProPost:
        r"""Generate an image with FLUX.1 [pro].

        Submits an image generation task with the FLUX.1 [pro].

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.FluxProInputs)
        request = cast(models.FluxProInputs, request)

        req = self._build_request(
            method="POST",
            path="/v1/flux-pro",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, True, "json", Optional[models.FluxProInputs]
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="flux_pro_v1_flux_pro_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.ResponseFluxProV1FluxProPost
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def flux_pro_v1_flux_pro_post_async(
        self,
        *,
        request: Union[
            models.FluxProInputs, models.FluxProInputsTypedDict
        ] = models.FluxProInputs(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseFluxProV1FluxProPost:
        r"""Generate an image with FLUX.1 [pro].

        Submits an image generation task with the FLUX.1 [pro].

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.FluxProInputs)
        request = cast(models.FluxProInputs, request)

        req = self._build_request_async(
            method="POST",
            path="/v1/flux-pro",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, True, "json", Optional[models.FluxProInputs]
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="flux_pro_v1_flux_pro_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.ResponseFluxProV1FluxProPost
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def flux_dev_v1_flux_dev_post(
        self,
        *,
        request: Union[
            models.FluxDevInputs, models.FluxDevInputsTypedDict
        ] = models.FluxDevInputs(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseFluxDevV1FluxDevPost:
        r"""Generate an image with FLUX.1 [dev].

        Submits an image generation task with FLUX.1 [dev].

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.FluxDevInputs)
        request = cast(models.FluxDevInputs, request)

        req = self._build_request(
            method="POST",
            path="/v1/flux-dev",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, True, "json", Optional[models.FluxDevInputs]
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="flux_dev_v1_flux_dev_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.ResponseFluxDevV1FluxDevPost
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def flux_dev_v1_flux_dev_post_async(
        self,
        *,
        request: Union[
            models.FluxDevInputs, models.FluxDevInputsTypedDict
        ] = models.FluxDevInputs(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseFluxDevV1FluxDevPost:
        r"""Generate an image with FLUX.1 [dev].

        Submits an image generation task with FLUX.1 [dev].

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.FluxDevInputs)
        request = cast(models.FluxDevInputs, request)

        req = self._build_request_async(
            method="POST",
            path="/v1/flux-dev",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, True, "json", Optional[models.FluxDevInputs]
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="flux_dev_v1_flux_dev_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.ResponseFluxDevV1FluxDevPost
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def generate_bigblue_v1_flux_pro_1_1_ultra_post(
        self,
        *,
        request: Union[
            models.FluxUltraInput, models.FluxUltraInputTypedDict
        ] = models.FluxUltraInput(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseGenerateBigblueV1FluxPro11UltraPost:
        r"""Generate an image with FLUX 1.1 [pro] with ultra mode and optional raw mode.

        Submits an image generation task with FLUX 1.1 [pro] with ultra mode and optional raw mode.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.FluxUltraInput)
        request = cast(models.FluxUltraInput, request)

        req = self._build_request(
            method="POST",
            path="/v1/flux-pro-1.1-ultra",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, True, "json", Optional[models.FluxUltraInput]
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="generate_bigblue_v1_flux_pro_1_1_ultra_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.ResponseGenerateBigblueV1FluxPro11UltraPost
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def generate_bigblue_v1_flux_pro_1_1_ultra_post_async(
        self,
        *,
        request: Union[
            models.FluxUltraInput, models.FluxUltraInputTypedDict
        ] = models.FluxUltraInput(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseGenerateBigblueV1FluxPro11UltraPost:
        r"""Generate an image with FLUX 1.1 [pro] with ultra mode and optional raw mode.

        Submits an image generation task with FLUX 1.1 [pro] with ultra mode and optional raw mode.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.FluxUltraInput)
        request = cast(models.FluxUltraInput, request)

        req = self._build_request_async(
            method="POST",
            path="/v1/flux-pro-1.1-ultra",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, True, "json", Optional[models.FluxUltraInput]
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="generate_bigblue_v1_flux_pro_1_1_ultra_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.ResponseGenerateBigblueV1FluxPro11UltraPost
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def fill_v1_flux_pro_1_0_fill_post(
        self,
        *,
        image: str,
        mask: OptionalNullable[str] = UNSET,
        prompt: OptionalNullable[str] = UNSET,
        steps: OptionalNullable[int] = UNSET,
        prompt_upsampling: OptionalNullable[bool] = UNSET,
        seed: OptionalNullable[int] = UNSET,
        guidance: OptionalNullable[float] = UNSET,
        output_format: OptionalNullable[models.OutputFormat] = UNSET,
        safety_tolerance: Optional[int] = 2,
        webhook_url: OptionalNullable[str] = UNSET,
        webhook_secret: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseFillV1FluxPro10FillPost:
        r"""Generate an image with FLUX.1 Fill [pro] using an input image and mask.

        Submits an image generation task with the FLUX.1 Fill [pro] model using an input image and mask. Mask can be applied to alpha channel or submitted as a separate image.

        :param image: A Base64-encoded string representing the image you wish to modify. Can contain alpha mask if desired.
        :param mask: A Base64-encoded string representing a mask for the areas you want to modify in the image. The mask should be the same dimensions as the image and in black and white. Black areas (0%) indicate no modification, while white areas (100%) specify areas for inpainting. Optional if you provide an alpha mask in the original image. Validation: The endpoint verifies that the dimensions of the mask match the original image.
        :param prompt: The description of the changes you want to make. This text guides the inpainting process, allowing you to specify features, styles, or modifications for the masked area.
        :param steps: Number of steps for the image generation process
        :param prompt_upsampling: Whether to perform upsampling on the prompt. If active, automatically modifies the prompt for more creative generation
        :param seed: Optional seed for reproducibility
        :param guidance: Guidance strength for the image generation process
        :param output_format: Output format for the generated image. Can be 'jpeg' or 'png'.
        :param safety_tolerance: Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
        :param webhook_url: URL to receive webhook notifications
        :param webhook_secret: Optional secret for webhook signature verification
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.FluxProFillInputs(
            image=image,
            mask=mask,
            prompt=prompt,
            steps=steps,
            prompt_upsampling=prompt_upsampling,
            seed=seed,
            guidance=guidance,
            output_format=output_format,
            safety_tolerance=safety_tolerance,
            webhook_url=webhook_url,
            webhook_secret=webhook_secret,
        )

        req = self._build_request(
            method="POST",
            path="/v1/flux-pro-1.0-fill",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.FluxProFillInputs
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="fill_v1_flux_pro_1_0_fill_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.ResponseFillV1FluxPro10FillPost
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def fill_v1_flux_pro_1_0_fill_post_async(
        self,
        *,
        image: str,
        mask: OptionalNullable[str] = UNSET,
        prompt: OptionalNullable[str] = UNSET,
        steps: OptionalNullable[int] = UNSET,
        prompt_upsampling: OptionalNullable[bool] = UNSET,
        seed: OptionalNullable[int] = UNSET,
        guidance: OptionalNullable[float] = UNSET,
        output_format: OptionalNullable[models.OutputFormat] = UNSET,
        safety_tolerance: Optional[int] = 2,
        webhook_url: OptionalNullable[str] = UNSET,
        webhook_secret: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseFillV1FluxPro10FillPost:
        r"""Generate an image with FLUX.1 Fill [pro] using an input image and mask.

        Submits an image generation task with the FLUX.1 Fill [pro] model using an input image and mask. Mask can be applied to alpha channel or submitted as a separate image.

        :param image: A Base64-encoded string representing the image you wish to modify. Can contain alpha mask if desired.
        :param mask: A Base64-encoded string representing a mask for the areas you want to modify in the image. The mask should be the same dimensions as the image and in black and white. Black areas (0%) indicate no modification, while white areas (100%) specify areas for inpainting. Optional if you provide an alpha mask in the original image. Validation: The endpoint verifies that the dimensions of the mask match the original image.
        :param prompt: The description of the changes you want to make. This text guides the inpainting process, allowing you to specify features, styles, or modifications for the masked area.
        :param steps: Number of steps for the image generation process
        :param prompt_upsampling: Whether to perform upsampling on the prompt. If active, automatically modifies the prompt for more creative generation
        :param seed: Optional seed for reproducibility
        :param guidance: Guidance strength for the image generation process
        :param output_format: Output format for the generated image. Can be 'jpeg' or 'png'.
        :param safety_tolerance: Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
        :param webhook_url: URL to receive webhook notifications
        :param webhook_secret: Optional secret for webhook signature verification
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.FluxProFillInputs(
            image=image,
            mask=mask,
            prompt=prompt,
            steps=steps,
            prompt_upsampling=prompt_upsampling,
            seed=seed,
            guidance=guidance,
            output_format=output_format,
            safety_tolerance=safety_tolerance,
            webhook_url=webhook_url,
            webhook_secret=webhook_secret,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/flux-pro-1.0-fill",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.FluxProFillInputs
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="fill_v1_flux_pro_1_0_fill_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.ResponseFillV1FluxPro10FillPost
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def pro_canny_v1_flux_pro_1_0_canny_post(
        self,
        *,
        prompt: str,
        control_image: OptionalNullable[str] = UNSET,
        preprocessed_image: OptionalNullable[str] = UNSET,
        canny_low_threshold: OptionalNullable[int] = UNSET,
        canny_high_threshold: OptionalNullable[int] = UNSET,
        prompt_upsampling: OptionalNullable[bool] = UNSET,
        seed: OptionalNullable[int] = UNSET,
        steps: OptionalNullable[int] = UNSET,
        output_format: OptionalNullable[models.OutputFormat] = UNSET,
        guidance: OptionalNullable[float] = UNSET,
        safety_tolerance: Optional[int] = 2,
        webhook_url: OptionalNullable[str] = UNSET,
        webhook_secret: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseProCannyV1FluxPro10CannyPost:
        r"""Generate an image with FLUX.1 Canny [pro] using a control image.

        Submits an image generation task with FLUX.1 Canny [pro].

        :param prompt: Text prompt for image generation
        :param control_image: Base64 encoded image to use as control input if no preprocessed image is provided
        :param preprocessed_image: Optional pre-processed image that will bypass the control preprocessing step
        :param canny_low_threshold: Low threshold for Canny edge detection
        :param canny_high_threshold: High threshold for Canny edge detection
        :param prompt_upsampling: Whether to perform upsampling on the prompt
        :param seed: Optional seed for reproducibility
        :param steps: Number of steps for the image generation process
        :param output_format: Output format for the generated image. Can be 'jpeg' or 'png'.
        :param guidance: Guidance strength for the image generation process
        :param safety_tolerance: Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
        :param webhook_url: URL to receive webhook notifications
        :param webhook_secret: Optional secret for webhook signature verification
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CannyInputs(
            prompt=prompt,
            control_image=control_image,
            preprocessed_image=preprocessed_image,
            canny_low_threshold=canny_low_threshold,
            canny_high_threshold=canny_high_threshold,
            prompt_upsampling=prompt_upsampling,
            seed=seed,
            steps=steps,
            output_format=output_format,
            guidance=guidance,
            safety_tolerance=safety_tolerance,
            webhook_url=webhook_url,
            webhook_secret=webhook_secret,
        )

        req = self._build_request(
            method="POST",
            path="/v1/flux-pro-1.0-canny",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CannyInputs
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="pro_canny_v1_flux_pro_1_0_canny_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.ResponseProCannyV1FluxPro10CannyPost
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def pro_canny_v1_flux_pro_1_0_canny_post_async(
        self,
        *,
        prompt: str,
        control_image: OptionalNullable[str] = UNSET,
        preprocessed_image: OptionalNullable[str] = UNSET,
        canny_low_threshold: OptionalNullable[int] = UNSET,
        canny_high_threshold: OptionalNullable[int] = UNSET,
        prompt_upsampling: OptionalNullable[bool] = UNSET,
        seed: OptionalNullable[int] = UNSET,
        steps: OptionalNullable[int] = UNSET,
        output_format: OptionalNullable[models.OutputFormat] = UNSET,
        guidance: OptionalNullable[float] = UNSET,
        safety_tolerance: Optional[int] = 2,
        webhook_url: OptionalNullable[str] = UNSET,
        webhook_secret: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseProCannyV1FluxPro10CannyPost:
        r"""Generate an image with FLUX.1 Canny [pro] using a control image.

        Submits an image generation task with FLUX.1 Canny [pro].

        :param prompt: Text prompt for image generation
        :param control_image: Base64 encoded image to use as control input if no preprocessed image is provided
        :param preprocessed_image: Optional pre-processed image that will bypass the control preprocessing step
        :param canny_low_threshold: Low threshold for Canny edge detection
        :param canny_high_threshold: High threshold for Canny edge detection
        :param prompt_upsampling: Whether to perform upsampling on the prompt
        :param seed: Optional seed for reproducibility
        :param steps: Number of steps for the image generation process
        :param output_format: Output format for the generated image. Can be 'jpeg' or 'png'.
        :param guidance: Guidance strength for the image generation process
        :param safety_tolerance: Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
        :param webhook_url: URL to receive webhook notifications
        :param webhook_secret: Optional secret for webhook signature verification
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CannyInputs(
            prompt=prompt,
            control_image=control_image,
            preprocessed_image=preprocessed_image,
            canny_low_threshold=canny_low_threshold,
            canny_high_threshold=canny_high_threshold,
            prompt_upsampling=prompt_upsampling,
            seed=seed,
            steps=steps,
            output_format=output_format,
            guidance=guidance,
            safety_tolerance=safety_tolerance,
            webhook_url=webhook_url,
            webhook_secret=webhook_secret,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/flux-pro-1.0-canny",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CannyInputs
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="pro_canny_v1_flux_pro_1_0_canny_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.ResponseProCannyV1FluxPro10CannyPost
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def pro_depth_v1_flux_pro_1_0_depth_post(
        self,
        *,
        prompt: str,
        control_image: OptionalNullable[str] = UNSET,
        preprocessed_image: OptionalNullable[str] = UNSET,
        prompt_upsampling: OptionalNullable[bool] = UNSET,
        seed: OptionalNullable[int] = UNSET,
        steps: OptionalNullable[int] = UNSET,
        output_format: OptionalNullable[models.OutputFormat] = UNSET,
        guidance: OptionalNullable[float] = UNSET,
        safety_tolerance: Optional[int] = 2,
        webhook_url: OptionalNullable[str] = UNSET,
        webhook_secret: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseProDepthV1FluxPro10DepthPost:
        r"""Generate an image with FLUX.1 Depth [pro] using a control image.

        Submits an image generation task with FLUX.1 Depth [pro].

        :param prompt: Text prompt for image generation
        :param control_image: Base64 encoded image to use as control input
        :param preprocessed_image: Optional pre-processed image that will bypass the control preprocessing step
        :param prompt_upsampling: Whether to perform upsampling on the prompt
        :param seed: Optional seed for reproducibility
        :param steps: Number of steps for the image generation process
        :param output_format: Output format for the generated image. Can be 'jpeg' or 'png'.
        :param guidance: Guidance strength for the image generation process
        :param safety_tolerance: Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
        :param webhook_url: URL to receive webhook notifications
        :param webhook_secret: Optional secret for webhook signature verification
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DepthInputs(
            prompt=prompt,
            control_image=control_image,
            preprocessed_image=preprocessed_image,
            prompt_upsampling=prompt_upsampling,
            seed=seed,
            steps=steps,
            output_format=output_format,
            guidance=guidance,
            safety_tolerance=safety_tolerance,
            webhook_url=webhook_url,
            webhook_secret=webhook_secret,
        )

        req = self._build_request(
            method="POST",
            path="/v1/flux-pro-1.0-depth",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.DepthInputs
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="pro_depth_v1_flux_pro_1_0_depth_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.ResponseProDepthV1FluxPro10DepthPost
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def pro_depth_v1_flux_pro_1_0_depth_post_async(
        self,
        *,
        prompt: str,
        control_image: OptionalNullable[str] = UNSET,
        preprocessed_image: OptionalNullable[str] = UNSET,
        prompt_upsampling: OptionalNullable[bool] = UNSET,
        seed: OptionalNullable[int] = UNSET,
        steps: OptionalNullable[int] = UNSET,
        output_format: OptionalNullable[models.OutputFormat] = UNSET,
        guidance: OptionalNullable[float] = UNSET,
        safety_tolerance: Optional[int] = 2,
        webhook_url: OptionalNullable[str] = UNSET,
        webhook_secret: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseProDepthV1FluxPro10DepthPost:
        r"""Generate an image with FLUX.1 Depth [pro] using a control image.

        Submits an image generation task with FLUX.1 Depth [pro].

        :param prompt: Text prompt for image generation
        :param control_image: Base64 encoded image to use as control input
        :param preprocessed_image: Optional pre-processed image that will bypass the control preprocessing step
        :param prompt_upsampling: Whether to perform upsampling on the prompt
        :param seed: Optional seed for reproducibility
        :param steps: Number of steps for the image generation process
        :param output_format: Output format for the generated image. Can be 'jpeg' or 'png'.
        :param guidance: Guidance strength for the image generation process
        :param safety_tolerance: Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
        :param webhook_url: URL to receive webhook notifications
        :param webhook_secret: Optional secret for webhook signature verification
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DepthInputs(
            prompt=prompt,
            control_image=control_image,
            preprocessed_image=preprocessed_image,
            prompt_upsampling=prompt_upsampling,
            seed=seed,
            steps=steps,
            output_format=output_format,
            guidance=guidance,
            safety_tolerance=safety_tolerance,
            webhook_url=webhook_url,
            webhook_secret=webhook_secret,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/flux-pro-1.0-depth",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.DepthInputs
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="pro_depth_v1_flux_pro_1_0_depth_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.ResponseProDepthV1FluxPro10DepthPost
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def finetune_v1_finetune_post(
        self,
        *,
        file_data: str,
        finetune_comment: str,
        mode: models.Mode,
        trigger_word: Optional[str] = "TOK",
        iterations: Optional[int] = 300,
        learning_rate: OptionalNullable[float] = UNSET,
        captioning: Optional[bool] = True,
        priority: Optional[models.Priority] = models.Priority.QUALITY,
        finetune_type: Optional[models.FinetuneType] = models.FinetuneType.FULL,
        lora_rank: Optional[models.LoraRank] = models.LoraRank.THIRTY_TWO,
        webhook_url: OptionalNullable[str] = UNSET,
        webhook_secret: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Any:
        r"""Finetune

        :param file_data: Base64-encoded ZIP file containing training images and, optionally, corresponding captions.
        :param finetune_comment: Comment or name of the fine-tuned model. This will be added as a field to the finetune_details.
        :param mode: Mode for the fine-tuned model. Allowed values are 'general', 'character', 'style', 'product'. This will affect the caption behaviour. General will describe the image in full detail.
        :param trigger_word: Trigger word for the fine-tuned model.
        :param iterations: Number of iterations for fine-tuning.
        :param learning_rate: Learning rate for fine-tuning. If not provided, defaults to 1e-5 for full fine-tuning and 1e-4 for lora fine-tuning.
        :param captioning: Whether to enable captioning during fine-tuning.
        :param priority: Priority of the fine-tuning process. 'speed' will prioritize iteration speed over quality, 'quality' will prioritize quality over speed.
        :param finetune_type: Type of fine-tuning. 'lora' is a standard LoRA Adapter, 'full' is a full fine-tuning mode, with a post hoc lora extraction.
        :param lora_rank: Rank of the fine-tuned model. 16 or 32. If finetune_type is 'full', this will be the rank of the extracted lora model.
        :param webhook_url: URL to receive webhook notifications
        :param webhook_secret: Optional secret for webhook signature verification
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.FinetuneInputs(
            file_data=file_data,
            finetune_comment=finetune_comment,
            trigger_word=trigger_word,
            mode=mode,
            iterations=iterations,
            learning_rate=learning_rate,
            captioning=captioning,
            priority=priority,
            finetune_type=finetune_type,
            lora_rank=lora_rank,
            webhook_url=webhook_url,
            webhook_secret=webhook_secret,
        )

        req = self._build_request(
            method="POST",
            path="/v1/finetune",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.FinetuneInputs
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="finetune_v1_finetune_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, Any)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def finetune_v1_finetune_post_async(
        self,
        *,
        file_data: str,
        finetune_comment: str,
        mode: models.Mode,
        trigger_word: Optional[str] = "TOK",
        iterations: Optional[int] = 300,
        learning_rate: OptionalNullable[float] = UNSET,
        captioning: Optional[bool] = True,
        priority: Optional[models.Priority] = models.Priority.QUALITY,
        finetune_type: Optional[models.FinetuneType] = models.FinetuneType.FULL,
        lora_rank: Optional[models.LoraRank] = models.LoraRank.THIRTY_TWO,
        webhook_url: OptionalNullable[str] = UNSET,
        webhook_secret: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Any:
        r"""Finetune

        :param file_data: Base64-encoded ZIP file containing training images and, optionally, corresponding captions.
        :param finetune_comment: Comment or name of the fine-tuned model. This will be added as a field to the finetune_details.
        :param mode: Mode for the fine-tuned model. Allowed values are 'general', 'character', 'style', 'product'. This will affect the caption behaviour. General will describe the image in full detail.
        :param trigger_word: Trigger word for the fine-tuned model.
        :param iterations: Number of iterations for fine-tuning.
        :param learning_rate: Learning rate for fine-tuning. If not provided, defaults to 1e-5 for full fine-tuning and 1e-4 for lora fine-tuning.
        :param captioning: Whether to enable captioning during fine-tuning.
        :param priority: Priority of the fine-tuning process. 'speed' will prioritize iteration speed over quality, 'quality' will prioritize quality over speed.
        :param finetune_type: Type of fine-tuning. 'lora' is a standard LoRA Adapter, 'full' is a full fine-tuning mode, with a post hoc lora extraction.
        :param lora_rank: Rank of the fine-tuned model. 16 or 32. If finetune_type is 'full', this will be the rank of the extracted lora model.
        :param webhook_url: URL to receive webhook notifications
        :param webhook_secret: Optional secret for webhook signature verification
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.FinetuneInputs(
            file_data=file_data,
            finetune_comment=finetune_comment,
            trigger_word=trigger_word,
            mode=mode,
            iterations=iterations,
            learning_rate=learning_rate,
            captioning=captioning,
            priority=priority,
            finetune_type=finetune_type,
            lora_rank=lora_rank,
            webhook_url=webhook_url,
            webhook_secret=webhook_secret,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/finetune",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.FinetuneInputs
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="finetune_v1_finetune_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, Any)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def flux_pro_finetuned_v1_flux_pro_finetuned_post(
        self,
        *,
        finetune_id: str,
        finetune_strength: Optional[float] = 1.1,
        steps: Optional[int] = 40,
        guidance: Optional[float] = 2.5,
        prompt: Optional[str] = "",
        image_prompt: OptionalNullable[str] = UNSET,
        width: Optional[int] = 1024,
        height: Optional[int] = 768,
        prompt_upsampling: Optional[bool] = False,
        seed: Optional[int] = None,
        safety_tolerance: Optional[int] = 2,
        output_format: Optional[models.OutputFormat] = None,
        webhook_url: OptionalNullable[str] = UNSET,
        webhook_secret: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseFluxProFinetunedV1FluxProFinetunedPost:
        r"""Generate an image with FLUX.1 [pro] finetune

        Submits an image generation task with FLUX.1 [pro] using a finetune.

        :param finetune_id: ID of the fine-tuned model you want to use.
        :param finetune_strength: Strength of the fine-tuned model. 0.0 means no influence, 1.0 means full influence. Allowed values up to 2.0
        :param steps: Number of steps for the fine-tuning process.
        :param guidance: Guidance scale for image generation. High guidance scales improve prompt adherence at the cost of reduced realism.
        :param prompt: Text prompt for image generation.
        :param image_prompt: Optional base64 encoded image to use with Flux Redux.
        :param width: Width of the generated image in pixels. Must be a multiple of 32.
        :param height: Height of the generated image in pixels. Must be a multiple of 32.
        :param prompt_upsampling: Whether to perform upsampling on the prompt. If active, automatically modifies the prompt for more creative generation.
        :param seed: Optional seed for reproducibility.
        :param safety_tolerance: Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
        :param output_format:
        :param webhook_url: URL to receive webhook notifications
        :param webhook_secret: Optional secret for webhook signature verification
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.FluxProFinetuneInputs(
            finetune_id=finetune_id,
            finetune_strength=finetune_strength,
            steps=steps,
            guidance=guidance,
            prompt=prompt,
            image_prompt=image_prompt,
            width=width,
            height=height,
            prompt_upsampling=prompt_upsampling,
            seed=seed,
            safety_tolerance=safety_tolerance,
            output_format=output_format,
            webhook_url=webhook_url,
            webhook_secret=webhook_secret,
        )

        req = self._build_request(
            method="POST",
            path="/v1/flux-pro-finetuned",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.FluxProFinetuneInputs
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="flux_pro_finetuned_v1_flux_pro_finetuned_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.ResponseFluxProFinetunedV1FluxProFinetunedPost
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def flux_pro_finetuned_v1_flux_pro_finetuned_post_async(
        self,
        *,
        finetune_id: str,
        finetune_strength: Optional[float] = 1.1,
        steps: Optional[int] = 40,
        guidance: Optional[float] = 2.5,
        prompt: Optional[str] = "",
        image_prompt: OptionalNullable[str] = UNSET,
        width: Optional[int] = 1024,
        height: Optional[int] = 768,
        prompt_upsampling: Optional[bool] = False,
        seed: Optional[int] = None,
        safety_tolerance: Optional[int] = 2,
        output_format: Optional[models.OutputFormat] = None,
        webhook_url: OptionalNullable[str] = UNSET,
        webhook_secret: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseFluxProFinetunedV1FluxProFinetunedPost:
        r"""Generate an image with FLUX.1 [pro] finetune

        Submits an image generation task with FLUX.1 [pro] using a finetune.

        :param finetune_id: ID of the fine-tuned model you want to use.
        :param finetune_strength: Strength of the fine-tuned model. 0.0 means no influence, 1.0 means full influence. Allowed values up to 2.0
        :param steps: Number of steps for the fine-tuning process.
        :param guidance: Guidance scale for image generation. High guidance scales improve prompt adherence at the cost of reduced realism.
        :param prompt: Text prompt for image generation.
        :param image_prompt: Optional base64 encoded image to use with Flux Redux.
        :param width: Width of the generated image in pixels. Must be a multiple of 32.
        :param height: Height of the generated image in pixels. Must be a multiple of 32.
        :param prompt_upsampling: Whether to perform upsampling on the prompt. If active, automatically modifies the prompt for more creative generation.
        :param seed: Optional seed for reproducibility.
        :param safety_tolerance: Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
        :param output_format:
        :param webhook_url: URL to receive webhook notifications
        :param webhook_secret: Optional secret for webhook signature verification
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.FluxProFinetuneInputs(
            finetune_id=finetune_id,
            finetune_strength=finetune_strength,
            steps=steps,
            guidance=guidance,
            prompt=prompt,
            image_prompt=image_prompt,
            width=width,
            height=height,
            prompt_upsampling=prompt_upsampling,
            seed=seed,
            safety_tolerance=safety_tolerance,
            output_format=output_format,
            webhook_url=webhook_url,
            webhook_secret=webhook_secret,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/flux-pro-finetuned",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.FluxProFinetuneInputs
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="flux_pro_finetuned_v1_flux_pro_finetuned_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.ResponseFluxProFinetunedV1FluxProFinetunedPost
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def flux_pro_1_0_depth_finetuned_v1_flux_pro_1_0_depth_finetuned_post(
        self,
        *,
        finetune_id: str,
        prompt: str,
        control_image: str,
        finetune_strength: Optional[float] = 1.1,
        prompt_upsampling: Optional[bool] = False,
        seed: OptionalNullable[int] = UNSET,
        steps: Optional[int] = 50,
        output_format: OptionalNullable[models.OutputFormat] = UNSET,
        guidance: Optional[float] = 15,
        safety_tolerance: Optional[int] = 2,
        webhook_url: OptionalNullable[str] = UNSET,
        webhook_secret: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseFluxPro10DepthFinetunedV1FluxPro10DepthFinetunedPost:
        r"""Generate an image with FLUX.1 Depth [pro] finetune using a control image.

        Submits an image generation task with FLUX.1 Depth [pro] finetune.

        :param finetune_id: ID of the fine-tuned model you want to use.
        :param prompt: Text prompt for image generation
        :param control_image: Base64 encoded image to use as control input
        :param finetune_strength: Strength of the fine-tuned model. 0.0 means no influence, 1.0 means full influence. Allowed values up to 2.0
        :param prompt_upsampling: Whether to perform upsampling on the prompt
        :param seed: Optional seed for reproducibility
        :param steps: Number of steps for the image generation process
        :param output_format: Output format for the generated image. Can be 'jpeg' or 'png'.
        :param guidance: Guidance strength for the image generation process
        :param safety_tolerance: Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
        :param webhook_url: URL to receive webhook notifications
        :param webhook_secret: Optional secret for webhook signature verification
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.FinetuneDepthInputs(
            finetune_id=finetune_id,
            finetune_strength=finetune_strength,
            prompt=prompt,
            control_image=control_image,
            prompt_upsampling=prompt_upsampling,
            seed=seed,
            steps=steps,
            output_format=output_format,
            guidance=guidance,
            safety_tolerance=safety_tolerance,
            webhook_url=webhook_url,
            webhook_secret=webhook_secret,
        )

        req = self._build_request(
            method="POST",
            path="/v1/flux-pro-1.0-depth-finetuned",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.FinetuneDepthInputs
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="flux_pro_1_0_depth_finetuned_v1_flux_pro_1_0_depth_finetuned_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.ResponseFluxPro10DepthFinetunedV1FluxPro10DepthFinetunedPost,
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def flux_pro_1_0_depth_finetuned_v1_flux_pro_1_0_depth_finetuned_post_async(
        self,
        *,
        finetune_id: str,
        prompt: str,
        control_image: str,
        finetune_strength: Optional[float] = 1.1,
        prompt_upsampling: Optional[bool] = False,
        seed: OptionalNullable[int] = UNSET,
        steps: Optional[int] = 50,
        output_format: OptionalNullable[models.OutputFormat] = UNSET,
        guidance: Optional[float] = 15,
        safety_tolerance: Optional[int] = 2,
        webhook_url: OptionalNullable[str] = UNSET,
        webhook_secret: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseFluxPro10DepthFinetunedV1FluxPro10DepthFinetunedPost:
        r"""Generate an image with FLUX.1 Depth [pro] finetune using a control image.

        Submits an image generation task with FLUX.1 Depth [pro] finetune.

        :param finetune_id: ID of the fine-tuned model you want to use.
        :param prompt: Text prompt for image generation
        :param control_image: Base64 encoded image to use as control input
        :param finetune_strength: Strength of the fine-tuned model. 0.0 means no influence, 1.0 means full influence. Allowed values up to 2.0
        :param prompt_upsampling: Whether to perform upsampling on the prompt
        :param seed: Optional seed for reproducibility
        :param steps: Number of steps for the image generation process
        :param output_format: Output format for the generated image. Can be 'jpeg' or 'png'.
        :param guidance: Guidance strength for the image generation process
        :param safety_tolerance: Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
        :param webhook_url: URL to receive webhook notifications
        :param webhook_secret: Optional secret for webhook signature verification
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.FinetuneDepthInputs(
            finetune_id=finetune_id,
            finetune_strength=finetune_strength,
            prompt=prompt,
            control_image=control_image,
            prompt_upsampling=prompt_upsampling,
            seed=seed,
            steps=steps,
            output_format=output_format,
            guidance=guidance,
            safety_tolerance=safety_tolerance,
            webhook_url=webhook_url,
            webhook_secret=webhook_secret,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/flux-pro-1.0-depth-finetuned",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.FinetuneDepthInputs
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="flux_pro_1_0_depth_finetuned_v1_flux_pro_1_0_depth_finetuned_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.ResponseFluxPro10DepthFinetunedV1FluxPro10DepthFinetunedPost,
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def flux_pro_1_0_canny_finetuned_v1_flux_pro_1_0_canny_finetuned_post(
        self,
        *,
        finetune_id: str,
        prompt: str,
        control_image: str,
        finetune_strength: Optional[float] = 1.1,
        canny_low_threshold: OptionalNullable[int] = UNSET,
        canny_high_threshold: OptionalNullable[int] = UNSET,
        prompt_upsampling: Optional[bool] = False,
        seed: OptionalNullable[int] = UNSET,
        steps: Optional[int] = 50,
        output_format: OptionalNullable[models.OutputFormat] = UNSET,
        guidance: Optional[float] = 30,
        safety_tolerance: Optional[int] = 2,
        webhook_url: OptionalNullable[str] = UNSET,
        webhook_secret: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseFluxPro10CannyFinetunedV1FluxPro10CannyFinetunedPost:
        r"""Generate an image with FLUX.1 Canny [pro] finetune using a control image.

        Submits an image generation task with FLUX.1 Canny [pro] finetune.

        :param finetune_id: ID of the fine-tuned model you want to use.
        :param prompt: Text prompt for image generation
        :param control_image: Base64 encoded image to use as control input
        :param finetune_strength: Strength of the fine-tuned model. 0.0 means no influence, 1.0 means full influence. Allowed values up to 2.0
        :param canny_low_threshold: Low threshold for Canny edge detection
        :param canny_high_threshold: High threshold for Canny edge detection
        :param prompt_upsampling: Whether to perform upsampling on the prompt
        :param seed: Optional seed for reproducibility
        :param steps: Number of steps for the image generation process
        :param output_format: Output format for the generated image. Can be 'jpeg' or 'png'.
        :param guidance: Guidance strength for the image generation process
        :param safety_tolerance: Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
        :param webhook_url: URL to receive webhook notifications
        :param webhook_secret: Optional secret for webhook signature verification
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.FinetuneCannyInputs(
            finetune_id=finetune_id,
            finetune_strength=finetune_strength,
            prompt=prompt,
            canny_low_threshold=canny_low_threshold,
            canny_high_threshold=canny_high_threshold,
            control_image=control_image,
            prompt_upsampling=prompt_upsampling,
            seed=seed,
            steps=steps,
            output_format=output_format,
            guidance=guidance,
            safety_tolerance=safety_tolerance,
            webhook_url=webhook_url,
            webhook_secret=webhook_secret,
        )

        req = self._build_request(
            method="POST",
            path="/v1/flux-pro-1.0-canny-finetuned",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.FinetuneCannyInputs
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="flux_pro_1_0_canny_finetuned_v1_flux_pro_1_0_canny_finetuned_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.ResponseFluxPro10CannyFinetunedV1FluxPro10CannyFinetunedPost,
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def flux_pro_1_0_canny_finetuned_v1_flux_pro_1_0_canny_finetuned_post_async(
        self,
        *,
        finetune_id: str,
        prompt: str,
        control_image: str,
        finetune_strength: Optional[float] = 1.1,
        canny_low_threshold: OptionalNullable[int] = UNSET,
        canny_high_threshold: OptionalNullable[int] = UNSET,
        prompt_upsampling: Optional[bool] = False,
        seed: OptionalNullable[int] = UNSET,
        steps: Optional[int] = 50,
        output_format: OptionalNullable[models.OutputFormat] = UNSET,
        guidance: Optional[float] = 30,
        safety_tolerance: Optional[int] = 2,
        webhook_url: OptionalNullable[str] = UNSET,
        webhook_secret: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseFluxPro10CannyFinetunedV1FluxPro10CannyFinetunedPost:
        r"""Generate an image with FLUX.1 Canny [pro] finetune using a control image.

        Submits an image generation task with FLUX.1 Canny [pro] finetune.

        :param finetune_id: ID of the fine-tuned model you want to use.
        :param prompt: Text prompt for image generation
        :param control_image: Base64 encoded image to use as control input
        :param finetune_strength: Strength of the fine-tuned model. 0.0 means no influence, 1.0 means full influence. Allowed values up to 2.0
        :param canny_low_threshold: Low threshold for Canny edge detection
        :param canny_high_threshold: High threshold for Canny edge detection
        :param prompt_upsampling: Whether to perform upsampling on the prompt
        :param seed: Optional seed for reproducibility
        :param steps: Number of steps for the image generation process
        :param output_format: Output format for the generated image. Can be 'jpeg' or 'png'.
        :param guidance: Guidance strength for the image generation process
        :param safety_tolerance: Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
        :param webhook_url: URL to receive webhook notifications
        :param webhook_secret: Optional secret for webhook signature verification
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.FinetuneCannyInputs(
            finetune_id=finetune_id,
            finetune_strength=finetune_strength,
            prompt=prompt,
            canny_low_threshold=canny_low_threshold,
            canny_high_threshold=canny_high_threshold,
            control_image=control_image,
            prompt_upsampling=prompt_upsampling,
            seed=seed,
            steps=steps,
            output_format=output_format,
            guidance=guidance,
            safety_tolerance=safety_tolerance,
            webhook_url=webhook_url,
            webhook_secret=webhook_secret,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/flux-pro-1.0-canny-finetuned",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.FinetuneCannyInputs
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="flux_pro_1_0_canny_finetuned_v1_flux_pro_1_0_canny_finetuned_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.ResponseFluxPro10CannyFinetunedV1FluxPro10CannyFinetunedPost,
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def flux_pro_1_0_fill_finetuned_v1_flux_pro_1_0_fill_finetuned_post(
        self,
        *,
        finetune_id: str,
        image: str,
        finetune_strength: Optional[float] = 1.1,
        mask: OptionalNullable[str] = UNSET,
        prompt: Optional[str] = "",
        steps: Optional[int] = 50,
        prompt_upsampling: Optional[bool] = False,
        seed: OptionalNullable[int] = UNSET,
        guidance: Optional[float] = 60,
        output_format: OptionalNullable[models.OutputFormat] = UNSET,
        safety_tolerance: Optional[int] = 2,
        webhook_url: OptionalNullable[str] = UNSET,
        webhook_secret: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseFluxPro10FillFinetunedV1FluxPro10FillFinetunedPost:
        r"""Generate an image with FLUX.1 Fill [pro] finetune using an input image and mask.

        Submits an image generation task with the FLUX.1 Fill [pro] finetune model using an input image and mask. Mask can be applied to alpha channel or submitted as a separate image.

        :param finetune_id: ID of the fine-tuned model you want to use.
        :param image: A Base64-encoded string representing the image you wish to modify. Can contain alpha mask if desired.
        :param finetune_strength: Strength of the fine-tuned model. 0.0 means no influence, 1.0 means full influence. Allowed values up to 2.0
        :param mask: A Base64-encoded string representing a mask for the areas you want to modify in the image. The mask should be the same dimensions as the image and in black and white. Black areas (0%) indicate no modification, while white areas (100%) specify areas for inpainting. Optional if you provide an alpha mask in the original image. Validation: The endpoint verifies that the dimensions of the mask match the original image.
        :param prompt: The description of the changes you want to make. This text guides the inpainting process, allowing you to specify features, styles, or modifications for the masked area.
        :param steps: Number of steps for the image generation process
        :param prompt_upsampling: Whether to perform upsampling on the prompt. If active, automatically modifies the prompt for more creative generation
        :param seed: Optional seed for reproducibility
        :param guidance: Guidance strength for the image generation process
        :param output_format: Output format for the generated image. Can be 'jpeg' or 'png'.
        :param safety_tolerance: Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
        :param webhook_url: URL to receive webhook notifications
        :param webhook_secret: Optional secret for webhook signature verification
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.FinetuneFluxProFillInputs(
            finetune_id=finetune_id,
            finetune_strength=finetune_strength,
            image=image,
            mask=mask,
            prompt=prompt,
            steps=steps,
            prompt_upsampling=prompt_upsampling,
            seed=seed,
            guidance=guidance,
            output_format=output_format,
            safety_tolerance=safety_tolerance,
            webhook_url=webhook_url,
            webhook_secret=webhook_secret,
        )

        req = self._build_request(
            method="POST",
            path="/v1/flux-pro-1.0-fill-finetuned",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.FinetuneFluxProFillInputs
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="flux_pro_1_0_fill_finetuned_v1_flux_pro_1_0_fill_finetuned_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.ResponseFluxPro10FillFinetunedV1FluxPro10FillFinetunedPost,
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def flux_pro_1_0_fill_finetuned_v1_flux_pro_1_0_fill_finetuned_post_async(
        self,
        *,
        finetune_id: str,
        image: str,
        finetune_strength: Optional[float] = 1.1,
        mask: OptionalNullable[str] = UNSET,
        prompt: Optional[str] = "",
        steps: Optional[int] = 50,
        prompt_upsampling: Optional[bool] = False,
        seed: OptionalNullable[int] = UNSET,
        guidance: Optional[float] = 60,
        output_format: OptionalNullable[models.OutputFormat] = UNSET,
        safety_tolerance: Optional[int] = 2,
        webhook_url: OptionalNullable[str] = UNSET,
        webhook_secret: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseFluxPro10FillFinetunedV1FluxPro10FillFinetunedPost:
        r"""Generate an image with FLUX.1 Fill [pro] finetune using an input image and mask.

        Submits an image generation task with the FLUX.1 Fill [pro] finetune model using an input image and mask. Mask can be applied to alpha channel or submitted as a separate image.

        :param finetune_id: ID of the fine-tuned model you want to use.
        :param image: A Base64-encoded string representing the image you wish to modify. Can contain alpha mask if desired.
        :param finetune_strength: Strength of the fine-tuned model. 0.0 means no influence, 1.0 means full influence. Allowed values up to 2.0
        :param mask: A Base64-encoded string representing a mask for the areas you want to modify in the image. The mask should be the same dimensions as the image and in black and white. Black areas (0%) indicate no modification, while white areas (100%) specify areas for inpainting. Optional if you provide an alpha mask in the original image. Validation: The endpoint verifies that the dimensions of the mask match the original image.
        :param prompt: The description of the changes you want to make. This text guides the inpainting process, allowing you to specify features, styles, or modifications for the masked area.
        :param steps: Number of steps for the image generation process
        :param prompt_upsampling: Whether to perform upsampling on the prompt. If active, automatically modifies the prompt for more creative generation
        :param seed: Optional seed for reproducibility
        :param guidance: Guidance strength for the image generation process
        :param output_format: Output format for the generated image. Can be 'jpeg' or 'png'.
        :param safety_tolerance: Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
        :param webhook_url: URL to receive webhook notifications
        :param webhook_secret: Optional secret for webhook signature verification
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.FinetuneFluxProFillInputs(
            finetune_id=finetune_id,
            finetune_strength=finetune_strength,
            image=image,
            mask=mask,
            prompt=prompt,
            steps=steps,
            prompt_upsampling=prompt_upsampling,
            seed=seed,
            guidance=guidance,
            output_format=output_format,
            safety_tolerance=safety_tolerance,
            webhook_url=webhook_url,
            webhook_secret=webhook_secret,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/flux-pro-1.0-fill-finetuned",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.FinetuneFluxProFillInputs
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="flux_pro_1_0_fill_finetuned_v1_flux_pro_1_0_fill_finetuned_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.ResponseFluxPro10FillFinetunedV1FluxPro10FillFinetunedPost,
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def generate_bigblue_finetuned_v1_flux_pro_1_1_ultra_finetuned_post(
        self,
        *,
        finetune_id: str,
        finetune_strength: Optional[float] = 1.2,
        prompt: OptionalNullable[str] = UNSET,
        seed: OptionalNullable[int] = UNSET,
        aspect_ratio: Optional[str] = "16:9",
        safety_tolerance: Optional[int] = 2,
        output_format: OptionalNullable[models.OutputFormat] = UNSET,
        image_prompt: OptionalNullable[str] = UNSET,
        image_prompt_strength: Optional[float] = 0.1,
        prompt_upsampling: Optional[bool] = False,
        webhook_url: OptionalNullable[str] = UNSET,
        webhook_secret: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseGenerateBigblueFinetunedV1FluxPro11UltraFinetunedPost:
        r"""Generate an image with FLUX 1.1 [pro] finetune with ultra mode.

        Submits an image generation task with FLUX 1.1 [pro] finetune with ultra mode.

        :param finetune_id: ID of the fine-tuned model you want to use.
        :param finetune_strength: Strength of the fine-tuned model. 0.0 means no influence, 1.0 means full influence. Allowed values up to 2.0
        :param prompt: The prompt to use for image generation.
        :param seed: Optional seed for reproducibility. If not provided, a random seed will be used.
        :param aspect_ratio: Aspect ratio of the image between 21:9 and 9:21
        :param safety_tolerance: Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
        :param output_format: Output format for the generated image. Can be 'jpeg' or 'png'.
        :param image_prompt: Optional image to remix in base64 format
        :param image_prompt_strength: Blend between the prompt and the image prompt
        :param prompt_upsampling: Whether to perform upsampling on the prompt. If active, automatically modifies the prompt for more creative generation
        :param webhook_url: URL to receive webhook notifications
        :param webhook_secret: Optional secret for webhook signature verification
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.FinetuneFluxUltraInput(
            finetune_id=finetune_id,
            finetune_strength=finetune_strength,
            prompt=prompt,
            seed=seed,
            aspect_ratio=aspect_ratio,
            safety_tolerance=safety_tolerance,
            output_format=output_format,
            image_prompt=image_prompt,
            image_prompt_strength=image_prompt_strength,
            prompt_upsampling=prompt_upsampling,
            webhook_url=webhook_url,
            webhook_secret=webhook_secret,
        )

        req = self._build_request(
            method="POST",
            path="/v1/flux-pro-1.1-ultra-finetuned",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.FinetuneFluxUltraInput
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="generate_bigblue_finetuned_v1_flux_pro_1_1_ultra_finetuned_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.ResponseGenerateBigblueFinetunedV1FluxPro11UltraFinetunedPost,
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def generate_bigblue_finetuned_v1_flux_pro_1_1_ultra_finetuned_post_async(
        self,
        *,
        finetune_id: str,
        finetune_strength: Optional[float] = 1.2,
        prompt: OptionalNullable[str] = UNSET,
        seed: OptionalNullable[int] = UNSET,
        aspect_ratio: Optional[str] = "16:9",
        safety_tolerance: Optional[int] = 2,
        output_format: OptionalNullable[models.OutputFormat] = UNSET,
        image_prompt: OptionalNullable[str] = UNSET,
        image_prompt_strength: Optional[float] = 0.1,
        prompt_upsampling: Optional[bool] = False,
        webhook_url: OptionalNullable[str] = UNSET,
        webhook_secret: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResponseGenerateBigblueFinetunedV1FluxPro11UltraFinetunedPost:
        r"""Generate an image with FLUX 1.1 [pro] finetune with ultra mode.

        Submits an image generation task with FLUX 1.1 [pro] finetune with ultra mode.

        :param finetune_id: ID of the fine-tuned model you want to use.
        :param finetune_strength: Strength of the fine-tuned model. 0.0 means no influence, 1.0 means full influence. Allowed values up to 2.0
        :param prompt: The prompt to use for image generation.
        :param seed: Optional seed for reproducibility. If not provided, a random seed will be used.
        :param aspect_ratio: Aspect ratio of the image between 21:9 and 9:21
        :param safety_tolerance: Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
        :param output_format: Output format for the generated image. Can be 'jpeg' or 'png'.
        :param image_prompt: Optional image to remix in base64 format
        :param image_prompt_strength: Blend between the prompt and the image prompt
        :param prompt_upsampling: Whether to perform upsampling on the prompt. If active, automatically modifies the prompt for more creative generation
        :param webhook_url: URL to receive webhook notifications
        :param webhook_secret: Optional secret for webhook signature verification
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.FinetuneFluxUltraInput(
            finetune_id=finetune_id,
            finetune_strength=finetune_strength,
            prompt=prompt,
            seed=seed,
            aspect_ratio=aspect_ratio,
            safety_tolerance=safety_tolerance,
            output_format=output_format,
            image_prompt=image_prompt,
            image_prompt_strength=image_prompt_strength,
            prompt_upsampling=prompt_upsampling,
            webhook_url=webhook_url,
            webhook_secret=webhook_secret,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/flux-pro-1.1-ultra-finetuned",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.FinetuneFluxUltraInput
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="generate_bigblue_finetuned_v1_flux_pro_1_1_ultra_finetuned_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.ResponseGenerateBigblueFinetunedV1FluxPro11UltraFinetunedPost,
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.HTTPValidationErrorData
            )
            raise errors.HTTPValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )
